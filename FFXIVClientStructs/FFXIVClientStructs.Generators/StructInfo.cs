using FFXIVClientStructs.Generators.Extensions;
using FFXIVClientStructs.Generators.Helpers;
using Microsoft.CodeAnalysis;

namespace FFXIVClientStructs.Generators;

internal sealed record StructInfo(
    string FullyQualifiedMetadataName,
    string Namespace,
    EquatableArray<string> Hierarchy) {

    public string Name => Hierarchy[0];

    internal static StructInfo FromRoslyn(INamedTypeSymbol structSymbol) {
        using ImmutableArrayBuilder<string> hierarchy = new();

        for (INamedTypeSymbol? parent = structSymbol;
             parent is not null;
             parent = parent.ContainingType) {
            hierarchy.Add(parent.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat));
        }

        return new StructInfo(
            structSymbol.GetNameWithContainingTypeAndNamespace(),
            structSymbol.ContainingNamespace.GetNameWithContainingTypeAndNamespace(),
            hierarchy.ToImmutable());
    }

    internal void RenderStart(IndentedTextWriter writer) {
        writer.WriteLine("// <auto-generated/>");
        writer.WriteLine();

        // write namespace 
        if (Namespace.Length > 0) {
            writer.WriteLine($"namespace {Namespace};");
            writer.WriteLine();
        }

        // write opening struct hierarchy in reverse order
        // note we do not need to specify the accessibility here since a partial declared with no accessibility uses the other partial
        for (int i = Hierarchy.Length - 1; i >= 0; i--) {
            writer.WriteLine($"unsafe partial struct {Hierarchy[i]}");
            writer.WriteLine("{");
            writer.IncreaseIndent();
        }
    }

    internal void RenderEnd(IndentedTextWriter writer) {
        // write closing struct hierarchy
        for (var i = 0; i < Hierarchy.Length; i++) {
            writer.DecreaseIndent();
            writer.WriteLine("}");
        }
    }
}
